/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.5.0, Date: 07-May-2021.
 */
package org.mobicents.gmlc.slee.lpp.LPP_PDU_Definitions;

import com.objsys.asn1j.runtime.*;

public class CommonIEsProvideLocationInformation extends Asn1Seq {
   private static final long serialVersionUID = 55;
   static {
      _setKey (_LPP_PDU_DefinitionsRtkey._rtkey);
      Asn1Type._setLicLocation(_LPP_PDU_DefinitionsRtkey._licLocation);
   }

   public String getAsn1TypeName()  {
      return "CommonIEsProvideLocationInformation";
   }

   protected LocationCoordinates locationEstimate;  // optional
   protected Velocity velocityEstimate;  // optional
   protected LocationError locationError;  // optional
   protected EarlyFixReport_r12 earlyFixReport_r12 = null;  // optional
   protected LocationSource_r13 locationSource_r13;  // optional
   protected Asn1UTCTime locationTimestamp_r13;  // optional
   protected SegmentationInfo_r14 segmentationInfo_r14 = null;  // optional
   protected Asn1OpenExt extElem1;

   public CommonIEsProvideLocationInformation () {
      super();
      init();
   }

   /**
    * This constructor sets all elements to references to the 
    * given objects
    */
   public CommonIEsProvideLocationInformation (
      LocationCoordinates locationEstimate_,
      Velocity velocityEstimate_,
      LocationError locationError_,
      EarlyFixReport_r12 earlyFixReport_r12_,
      LocationSource_r13 locationSource_r13_,
      Asn1UTCTime locationTimestamp_r13_,
      SegmentationInfo_r14 segmentationInfo_r14_
   ) throws Asn1Exception {
      super();
      setLocationEstimate (locationEstimate_);
      setVelocityEstimate (velocityEstimate_);
      setLocationError (locationError_);
      setEarlyFixReport_r12 (earlyFixReport_r12_);
      setLocationSource_r13 (locationSource_r13_);
      setLocationTimestamp_r13 (locationTimestamp_r13_);
      setSegmentationInfo_r14 (segmentationInfo_r14_);
   }

   /**
    * This constructor allows primitive data to be passed for all 
    * primitive elements.  It will create new object wrappers for 
    * the primitive data and set other elements to references to 
    * the given objects 
    */
   public CommonIEsProvideLocationInformation (LocationCoordinates locationEstimate_,
      Velocity velocityEstimate_,
      LocationError locationError_,
      EarlyFixReport_r12 earlyFixReport_r12_,
      LocationSource_r13 locationSource_r13_,
      String locationTimestamp_r13_,
      SegmentationInfo_r14 segmentationInfo_r14_
   ) throws Asn1Exception {
      super();
      setLocationEstimate (locationEstimate_);
      setVelocityEstimate (velocityEstimate_);
      setLocationError (locationError_);
      setEarlyFixReport_r12 (earlyFixReport_r12_);
      setLocationSource_r13 (locationSource_r13_);
      setLocationTimestamp_r13 (locationTimestamp_r13_);
      setSegmentationInfo_r14 (segmentationInfo_r14_);
   }

   public void init () {
      locationEstimate = null;
      velocityEstimate = null;
      locationError = null;
      earlyFixReport_r12 = null;
      locationSource_r13 = null;
      locationTimestamp_r13 = null;
      segmentationInfo_r14 = null;
      extElem1 = null;
   }

   public boolean equals( Object obj ) {
      if ( this == obj ) return true;
      if ( !(obj instanceof CommonIEsProvideLocationInformation) ) return false;

      CommonIEsProvideLocationInformation rhs = (CommonIEsProvideLocationInformation) obj;

      if (locationEstimate == null) {
         if (rhs.locationEstimate != null) return false;
      }
      else {
         if (!locationEstimate.equals(rhs.locationEstimate)) {
            return false;
         }
      }

      if (velocityEstimate == null) {
         if (rhs.velocityEstimate != null) return false;
      }
      else {
         if (!velocityEstimate.equals(rhs.velocityEstimate)) {
            return false;
         }
      }

      if (locationError == null) {
         if (rhs.locationError != null) return false;
      }
      else {
         if (!locationError.equals(rhs.locationError)) {
            return false;
         }
      }

      if (earlyFixReport_r12 == null) {
         if (rhs.earlyFixReport_r12 != null) return false;
      }
      else {
         if (!earlyFixReport_r12.equals(rhs.earlyFixReport_r12)) {
            return false;
         }
      }

      if (locationSource_r13 == null) {
         if (rhs.locationSource_r13 != null) return false;
      }
      else {
         if (!locationSource_r13.equals(rhs.locationSource_r13)) {
            return false;
         }
      }

      if (locationTimestamp_r13 == null) {
         if (rhs.locationTimestamp_r13 != null) return false;
      }
      else {
         if (!locationTimestamp_r13.equals(rhs.locationTimestamp_r13)) {
            return false;
         }
      }

      if (segmentationInfo_r14 == null) {
         if (rhs.segmentationInfo_r14 != null) return false;
      }
      else {
         if (!segmentationInfo_r14.equals(rhs.segmentationInfo_r14)) {
            return false;
         }
      }

      if (extElem1 == null) {
         if (rhs.extElem1 != null) return false;
      }
      else {
         if (!extElem1.equals(rhs.extElem1)) {
            return false;
         }
      }

      return true;
   }

   public int hashCode() {
      int __code = 1;

      if (locationEstimate != null) __code = 31*__code + locationEstimate.hashCode();
      if (velocityEstimate != null) __code = 31*__code + velocityEstimate.hashCode();
      if (locationError != null) __code = 31*__code + locationError.hashCode();
      if (earlyFixReport_r12 != null) __code = 31*__code + earlyFixReport_r12.hashCode();
      if (locationSource_r13 != null) __code = 31*__code + locationSource_r13.hashCode();
      if (locationTimestamp_r13 != null) __code = 31*__code + locationTimestamp_r13.hashCode();
      if (segmentationInfo_r14 != null) __code = 31*__code + segmentationInfo_r14.hashCode();
      if (extElem1 != null) __code = 31*__code + extElem1.hashCode();

      return __code;
   }

   /**
    * Accessor/mutator methods for LocationEstimate
    */
   public LocationCoordinates getLocationEstimate () {
      return locationEstimate;
   }

   public void setLocationEstimate (LocationCoordinates value) {
      this.locationEstimate = value;
   }

   public boolean hasLocationEstimate () {
      return (locationEstimate != null);
   }

   /**
    * Accessor/mutator methods for VelocityEstimate
    */
   public Velocity getVelocityEstimate () {
      return velocityEstimate;
   }

   public void setVelocityEstimate (Velocity value) {
      this.velocityEstimate = value;
   }

   public boolean hasVelocityEstimate () {
      return (velocityEstimate != null);
   }

   /**
    * Accessor/mutator methods for LocationError
    */
   public LocationError getLocationError () {
      return locationError;
   }

   public void setLocationError (LocationError value) {
      this.locationError = value;
   }

   public boolean hasLocationError () {
      return (locationError != null);
   }

   /**
    * Accessor/mutator methods for EarlyFixReport_r12
    */
   public EarlyFixReport_r12 getEarlyFixReport_r12 () {
      return earlyFixReport_r12;
   }

   public void setEarlyFixReport_r12 (EarlyFixReport_r12 value) {
      this.earlyFixReport_r12 = value;
   }

   public boolean hasEarlyFixReport_r12 () {
      return (earlyFixReport_r12 != null);
   }

   /**
    * Accessor/mutator methods for LocationSource_r13
    */
   public LocationSource_r13 getLocationSource_r13 () {
      return locationSource_r13;
   }

   public void setLocationSource_r13 (LocationSource_r13 value) 
      throws Asn1Exception
   {
      if (!((value.getLength() >= 1 && value.getLength() <= 16))) {
         throw new Asn1ConsVioException ("value.getLength()", value.getLength());
      }

      this.locationSource_r13 = value;
   }

   public boolean hasLocationSource_r13 () {
      return (locationSource_r13 != null);
   }

   /**
    * Accessor/mutator methods for LocationTimestamp_r13
    */
   public Asn1UTCTime getLocationTimestamp_r13 () {
      return locationTimestamp_r13;
   }

   public void setLocationTimestamp_r13 (Asn1UTCTime value) {
      this.locationTimestamp_r13 = value;
   }

   public void setLocationTimestamp_r13 (String value) {
      setLocationTimestamp_r13 (new Asn1UTCTime(value));
   }
   public boolean hasLocationTimestamp_r13 () {
      return (locationTimestamp_r13 != null);
   }

   /**
    * Accessor/mutator methods for SegmentationInfo_r14
    */
   public SegmentationInfo_r14 getSegmentationInfo_r14 () {
      return segmentationInfo_r14;
   }

   public void setSegmentationInfo_r14 (SegmentationInfo_r14 value) {
      this.segmentationInfo_r14 = value;
   }

   public boolean hasSegmentationInfo_r14 () {
      return (segmentationInfo_r14 != null);
   }

   /**
    * Accessor/mutator methods for ExtElem1
    */
   public Asn1OpenExt getExtElem1 () {
      return extElem1;
   }

   public void setExtElem1 (Asn1OpenExt value) {
      this.extElem1 = value;
   }

   public int getElementCount() { return 8; }


   public Object getElementValue(int index){
      switch(index)  {
         case 0: return locationEstimate;
         case 1: return velocityEstimate;
         case 2: return locationError;
         case 3: return earlyFixReport_r12;
         case 4: return locationSource_r13;
         case 5: return locationTimestamp_r13;
         case 6: return segmentationInfo_r14;
         case 7: return extElem1;
         default: return null;
      }
   }


   public String getElementName(int index){
      switch(index)  {
         case 0: return "locationEstimate";
         case 1: return "velocityEstimate";
         case 2: return "locationError";
         case 3: return "earlyFixReport-r12";
         case 4: return "locationSource-r13";
         case 5: return "locationTimestamp-r13";
         case 6: return "segmentationInfo-r14";
         case 7: return null;
         default: return null;
      }
   }


   public void decode (Asn1PerDecodeBuffer buffer)
      throws Asn1Exception, java.io.IOException
   {
      init ();

      // extension bit

      boolean extbit = buffer.decodeBit ("extbit");

      // optional bits

      boolean locationEstimatePresent = buffer.decodeBit ("locationEstimatePresent");
      boolean velocityEstimatePresent = buffer.decodeBit ("velocityEstimatePresent");
      boolean locationErrorPresent = buffer.decodeBit ("locationErrorPresent");

      // decode locationEstimate

      if (locationEstimatePresent) {
         buffer.getContext().eventDispatcher.startElement("locationEstimate", -1);

         locationEstimate = new LocationCoordinates();
         locationEstimate.decode (buffer);
         buffer.getContext().eventDispatcher.endElement("locationEstimate", -1);
      }
      else {
         locationEstimate = null;
      }

      // decode velocityEstimate

      if (velocityEstimatePresent) {
         buffer.getContext().eventDispatcher.startElement("velocityEstimate", -1);

         velocityEstimate = new Velocity();
         velocityEstimate.decode (buffer);
         buffer.getContext().eventDispatcher.endElement("velocityEstimate", -1);
      }
      else {
         velocityEstimate = null;
      }

      // decode locationError

      if (locationErrorPresent) {
         buffer.getContext().eventDispatcher.startElement("locationError", -1);

         locationError = new LocationError();
         locationError.decode (buffer);
         buffer.getContext().eventDispatcher.endElement("locationError", -1);
      }
      else {
         locationError = null;
      }

      if (extbit) {

         int bitcnt = buffer.decodeSmallLength(), i = 0;
         long bitidx = buffer.getBitOffset() + bitcnt;
         boolean[] bitmap = new boolean [bitcnt];

         if (i < bitcnt) bitmap[i++] = buffer.decodeBit ("earlyFixReport_r12Present");
         if (i < bitcnt) bitmap[i++] = buffer.decodeBit ("locationSource_r13Present");
         if (i < bitcnt) bitmap[i++] = buffer.decodeBit ("locationTimestamp_r13Present");
         if (i < bitcnt) bitmap[i++] = buffer.decodeBit ("segmentationInfo_r14Present");

         while (i < bitcnt) {
            bitmap[i++] = buffer.decodeBit ("unknown");
         }

         i = 0;

         // decode earlyFixReport_r12

         if (i < bitcnt && bitmap[i++]) {
            buffer.getContext().eventDispatcher.startElement("earlyFixReport_r12", -1);

            long _curidx = buffer.getBitOffset();
            bitidx = buffer.decodeExtLength ();
            if (bitidx - _curidx >= 131088)  {
               throw new Asn1Exception ("PER fragmentation not enabled: add -perindef to decode");
            }

            {
               int tval = EarlyFixReport_r12.decodeEnumValue (buffer);
               earlyFixReport_r12 = EarlyFixReport_r12.valueOf (tval);
               buffer.moveBitCursor (bitidx);
            }
            buffer.getContext().eventDispatcher.endElement("earlyFixReport_r12", -1);

         }
         else {
            earlyFixReport_r12 = null;
         }

         // decode locationSource_r13

         if (i < bitcnt && bitmap[i++]) {
            buffer.getContext().eventDispatcher.startElement("locationSource_r13", -1);

            long _curidx = buffer.getBitOffset();
            bitidx = buffer.decodeExtLength ();
            if (bitidx - _curidx >= 131088)  {
               throw new Asn1Exception ("PER fragmentation not enabled: add -perindef to decode");
            }

            locationSource_r13 = new LocationSource_r13();
            locationSource_r13.decode (buffer);

            buffer.moveBitCursor (bitidx);
            buffer.getContext().eventDispatcher.endElement("locationSource_r13", -1);

         }
         else {
            locationSource_r13 = null;
         }

         // decode locationTimestamp_r13

         if (i < bitcnt && bitmap[i++]) {
            buffer.getContext().eventDispatcher.startElement("locationTimestamp_r13", -1);

            long _curidx = buffer.getBitOffset();
            bitidx = buffer.decodeExtLength ();
            if (bitidx - _curidx >= 131088)  {
               throw new Asn1Exception ("PER fragmentation not enabled: add -perindef to decode");
            }

            locationTimestamp_r13 = new Asn1UTCTime (true);
            locationTimestamp_r13.decode (buffer, (Asn1CharSet)null);

            buffer.moveBitCursor (bitidx);
            buffer.getContext().eventDispatcher.endElement("locationTimestamp_r13", -1);

         }
         else {
            locationTimestamp_r13 = null;
         }

         // decode segmentationInfo_r14

         if (i < bitcnt && bitmap[i++]) {
            buffer.getContext().eventDispatcher.startElement("segmentationInfo_r14", -1);

            long _curidx = buffer.getBitOffset();
            bitidx = buffer.decodeExtLength ();
            if (bitidx - _curidx >= 131088)  {
               throw new Asn1Exception ("PER fragmentation not enabled: add -perindef to decode");
            }

            {
               int tval = SegmentationInfo_r14.decodeEnumValue (buffer);
               segmentationInfo_r14 = SegmentationInfo_r14.valueOf (tval);
               buffer.moveBitCursor (bitidx);
            }
            buffer.getContext().eventDispatcher.endElement("segmentationInfo_r14", -1);

         }
         else {
            segmentationInfo_r14 = null;
         }

         // decode unknown extension elements

         if (i < bitcnt) {
            Asn1OpenType openType = null;
            extElem1 = new Asn1OpenExt();
            int j = 0;
            while (i < bitcnt) {
               if (bitmap[i]) {
                  buffer.getContext().eventDispatcher.startElement("...", -1);

                  openType = extElem1.decodeOpenType (buffer, true, j++);
               }
               else {
                  extElem1.setOpenType (null, j++);
               }
               i++;
            }
         }
         buffer.byteAlign ();

      }

   }

   public void encode (Asn1PerEncodeBuffer buffer)
      throws Asn1Exception, java.io.IOException
   {
      // extension bit

      boolean extbit = ((earlyFixReport_r12 != null) ||
      (locationSource_r13 != null) ||
      (locationTimestamp_r13 != null) ||
      (segmentationInfo_r14 != null) ||
      ((extElem1 != null) && (!extElem1.value.isEmpty()))
      );

      buffer.encodeBit (extbit, "extbit");

      // encode optional elements bit mask

      buffer.encodeBit ((locationEstimate != null), null);
      buffer.encodeBit ((velocityEstimate != null), null);
      buffer.encodeBit ((locationError != null), null);

      // encode locationEstimate

      if (locationEstimate != null) {
         buffer.getContext().eventDispatcher.startElement("locationEstimate", -1);

         locationEstimate.encode (buffer);

         buffer.getContext().eventDispatcher.endElement("locationEstimate", -1);
      }

      // encode velocityEstimate

      if (velocityEstimate != null) {
         buffer.getContext().eventDispatcher.startElement("velocityEstimate", -1);

         velocityEstimate.encode (buffer);

         buffer.getContext().eventDispatcher.endElement("velocityEstimate", -1);
      }

      // encode locationError

      if (locationError != null) {
         buffer.getContext().eventDispatcher.startElement("locationError", -1);

         locationError.encode (buffer);

         buffer.getContext().eventDispatcher.endElement("locationError", -1);
      }

      if (extbit) {

         // encode extension optional bits length

         int bitcnt = 4;
         if (extElem1 != null) bitcnt += extElem1.value.size();
         buffer.encodeSmallLength (bitcnt);

         // encode optional bits

         buffer.encodeBit ((earlyFixReport_r12 != null), null);
         buffer.encodeBit ((locationSource_r13 != null), null);
         buffer.encodeBit ((locationTimestamp_r13 != null), null);
         buffer.encodeBit ((segmentationInfo_r14 != null), null);

         if (extElem1 != null && extElem1.value.size() > 0) {
            extElem1.encodeExtBits (buffer);
         }

         // encode extension elements

         Asn1PerEncodeBuffer mainBuffer = buffer;
         buffer = new Asn1PerEncodeBuffer (buffer.isAligned());

         // earlyFixReport_r12

         if (earlyFixReport_r12 != null) {
            buffer.reset();
            earlyFixReport_r12.encode (buffer);
            buffer.getContext().eventDispatcher.startElement("earlyFixReport_r12", -1);

            mainBuffer.encodeOpenType (buffer, null);

            buffer.getContext().eventDispatcher.endElement("earlyFixReport_r12", -1);
         }

         // locationSource_r13

         if (locationSource_r13 != null) {
            buffer.reset();
            locationSource_r13.encode (buffer);
            buffer.getContext().eventDispatcher.startElement("locationSource_r13", -1);

            mainBuffer.encodeOpenType (buffer, null);

            buffer.getContext().eventDispatcher.endElement("locationSource_r13", -1);
         }

         // locationTimestamp_r13

         if (locationTimestamp_r13 != null) {
            buffer.reset();
            locationTimestamp_r13.encode (buffer, (Asn1CharSet)null);
            buffer.getContext().eventDispatcher.startElement("locationTimestamp_r13", -1);

            mainBuffer.encodeOpenType (buffer, null);

            buffer.getContext().eventDispatcher.endElement("locationTimestamp_r13", -1);
         }

         // segmentationInfo_r14

         if (segmentationInfo_r14 != null) {
            buffer.reset();
            segmentationInfo_r14.encode (buffer);
            buffer.getContext().eventDispatcher.startElement("segmentationInfo_r14", -1);

            mainBuffer.encodeOpenType (buffer, null);

            buffer.getContext().eventDispatcher.endElement("segmentationInfo_r14", -1);
         }

         buffer = mainBuffer;

         if (extElem1 != null && extElem1.value.size() > 0) {
            extElem1.encode (buffer);
         }
      }
   }

}
